# -*- coding: utf-8 -*-
"""H_Test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-HefLKXiwlAZMjUbsyCz7yDj3nnoyxi0
"""

from numpy.random import normal
import pandas as pd
import numpy as np
from numpy import std, mean, sqrt
from itertools import combinations
import matplotlib.pyplot as plt
import pylab as py
from collections import Counter
import math
import itertools
import pingouin as pg


from scipy import stats
from pingouin import ttest
import statsmodels.api as sm

from scipy.stats import shapiro
from scipy.stats import f_oneway
from scipy.stats import spearmanr
from scipy.stats import ks_2samp
from scipy.stats import kstest
from scipy.stats import bartlett
from scipy.stats import levene
from scipy.stats import norm
from scipy.stats import normaltest
from scipy.stats import anderson
from scipy.stats import mannwhitneyu
from scipy.stats import wilcoxon

class H_Test():

  def __init__(self, samples, significance = 0.05):
    self.samples = samples
    self.a = significance
    

  def mean(self):
    M = {}
    for k in self.samples:
      M.update({k:self.samples[k].mean()})
    return M

  def var(self):
    V = {}
    for k in self.samples:
      V.update({k:self.samples[k].var()})

    return V


  def is_normal(self, test = 'shapiro'):
    T = ['shapiro', 'anderson_darling','1s_kolm']
    if test not in T:
      raise Exception("Sorry, test not included")
    L = {}
    for k in self.samples:
      normal = True
      if test == 'shapiro':
        if shapiro(self.samples[k])[1] < self.a:
          normal = False
        p_val = shapiro(self.samples[k])[1]

      elif test == 'anderson_darling':
        if anderson(self.samples[k])[1] < self.a:
          normal = False
        p_val = anderson(self.samples[k])[1]
      
      elif test == '1s_kolm':
        if kstest(self.samples[k],'norm')[1] < self.a:
          normal = False
        p_val = kstest(self.samples[k],'norm')[1]
      L.update({k:[normal,{'p_val':p_val}]})
      
    return L

  def is_homoscedastic(self):
    if len(self.samples) < 2:
      raise Exception("Sorry, not enough samples")
    homoscedasticity = True
    p_val = levene(*list(self.samples.values()))[1]
    if levene(*list(self.samples.values()))[1] < self.a:
      
      homoscedasticity = False
    return [homoscedasticity, p_val]

  def assumptions(self, test = 'shapiro'):
    T = ['shapiro','D_Agostino', 'anderson_darling','qq','1s_kolm']
    if len(self.samples) < 2:
      raise Exception("Sorry, not enough samples")
    elif test not in T:
      raise Exception("Sorry, test not included")
    n = self.is_normal(test)
    h = self.is_homoscedastic()[0]
    normal = True
    for k in n:
      if n[k] == False:
        normal = False
    return normal and h
  
  def many_samples(self, test = 'ANOVA'):
    observations = len(self.samples)*26
    T = ['ANOVA', 'kruskal']
    if len(self.samples) < 2:
      raise Exception("Sorry, not enough samples")
    elif test not in T:
      raise Exception("Sorry, test not included")
    assumptions = self.assumptions()
    if test == 'ANOVA':
      if assumptions:
        statistic, p_value = f_oneway(*list(self.samples.values()))
      else:
        p_value = 0
      D = {'assumptions':assumptions, 'H1':p_value < self.a, 'p_val': p_value}
    elif test == 'kruskal':
      statistic, p_value = stats.kruskal(*list(self.samples.values()))
      effect = statistic / ((observations**2 - 1) / (observations+1))
      k = p_value, statistic 
      D = [{'p_value and statistic': k},{'effect size':effect}, {'H1':p_value < self.a}]
    return D

  

  def histogram(self, bins = 10):
    for i in self.samples:
      plt.hist(self.samples[i], bins = bins)
      plt.show()

 
  def qq(self, dist = norm, line = '45'):
    for i in self.samples:
      sm.qqplot(self.samples[i], line =line,dist = dist)
      py.show()



  def s2_test(self, test, s = 'two-sided'):
    T = ['t_student','t_student_pin','spearman','2s_kolmogorov','mannwhitneyu']
    if len(self.samples) < 2:
      raise Exception("Sorry, not enough samples")
    elif test not in T:
      raise Exception("Sorry, test not included")
    M = list(combinations(list(self.samples.items()),2))
    d = {}
    for i in M:
      d.update({i[0][0]+' and '+i[1][0]: [i[0][1], i[1][1]]})
    n = {}
    m = {}
    for k in d:
      if test == 't_student':
        
        for j in d:
          m.update({j:H_Test({'a':d[j][0],'b':d[j][1]}).is_normal()['a'][0] and H_Test({'a':d[j][0],'b':d[j][1]}).is_normal()['b'][0]})
        for k in m:
          
          if m[k] == True:
            t_test,p_val = stats.ttest_ind(d[k][0], d[k][1], alternative = s)
            #Cohen d
            effect = abs((mean(d[k][0]) - mean(d[k][1])) / sqrt((std(d[k][0], ddof=1) ** 2 + std(d[k][1], ddof=1) ** 2) / 2.0))
            
            t = p_val, t_test
            n.update({k: [{'p_val and t_score':t},{'effect size':effect},{'H1':p_val < self.a}]})
      elif test == 't_student_pin':
      	table = ttest(d[k][0], d[k][1], paired=False, alternative=s)
      	n.update({'t_student_pingouin':table})  
      elif test == 'spearman':
        s_test,p_val = stats.spearmanr(d[k][0], d[k][1])
        n.update({k:[{'p_val':p_val} , {'H1':p_val < self.a}]})
      elif test == '2s_kolmogorov':
        s_test,p_val = stats.ks_2samp(d[k][0], d[k][1])
        n.update({k:[{'p_val':p_val} , {'H1':p_val < self.a}]})
      elif test == 'mannwhitneyu':
        s_test,p_val = stats.mannwhitneyu(d[k][0], d[k][1])
        n.update({k:[{'p_val':p_val} , {'H1':p_val < self.a}]})

    return n 

   
def transform(D, s):
  L = []
  for k in D:
    if 'none' not in k:
      L.append([k]*26)
  M = list(itertools.chain(*L))
  df = pd.DataFrame(columns = ['accuracy'])
  for i in D:
    if 'none' not in i:
      df = df.append(pd.DataFrame(list(D[i]), columns=['accuracy']), ignore_index = True)
  df[s] = M
      
  return df
  

def ANOVA(D, s = 'cnn_noise'):
  test = H_Test(D)
  assumptions = test.assumptions()
  df = transform(D, s)
  aov = pg.anova(dv='accuracy', between=s , data=df, effsize = 'n2',
               detailed=True)
  return assumptions, aov
